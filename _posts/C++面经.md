---
layout: post
title: c++面经
subtitle: c++
categories: markdown
tags: [c++, 面经]
---

# C++语言特点

## 问题: C++与JAVA有什么区别？

关键词： 虚拟机`JVM`（代码的可移植性强）、编译型语言与解释型语言(生态差很多)、完全面向对象、垃圾回收、效率

`JVM`简介：`JVM`（Java [Virtual](https://so.csdn.net/so/search?q=Virtual&spm=1001.2101.3001.7020) Machine），俗称Java虚拟机。**它是一个虚构出来的计算机**，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。

## 问题: C++与Python有什么区别？

关键词： 编译型语言与解释型语言(生态差很多)、使用的简单性(不用定义变量类型，会根据你的辅助自动推导)、方便性（大量的库）、效率

## 问题: C++与C语言有什么区别？

关键词: 面向过程(两种程序设计思想之一)、安全性(```malloc```的裸指针、类型转换、越界溢出)、实用性(STL、异常捕获)、效率。

- 面向对象编程：支持封装继承多态

- 安全性：相比于C语言，C++提供了一些新的机制保障类型安全：

  - 动态管理内存：操作符```new```返回的指针类型严格与对象匹配，而不是```void*```

  - 替代宏(`const` \ `inline`):引入```const```关键字代替```#define constants```，它是有类型、有作用域的，而```#define constants```只是简单的文本替换; 一些#define宏可被改写为```inline```函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全

  - 类型转换：C++提供了```dynamic_cast```关键字，使得转换过程更加安全，因为```dynamic_cast```比```static_cast```涉及更多具体的类型检查。

- 实用性：

  - STL提供了高可用性、高移植性的代码;
  - 异常捕获机制(catch);

### 问题：简单聊一聊面向对象(**OOP**)和面向过程(OPM)? 

面向对象与面向过程是两种编程思想：

- 面向过程写起来简单，按照着算法设计写就行；
- 面向对象需要对任务做对象分析，需要有哪些对象，对象由哪些属性，对象有啥左右，对象怎么与其他对象进行交互等等细节. 最大的好处就是屏蔽节点内步实现细节，只提供有用的接口。

大佬的理解：

>  OOP应该体现一种网状结构，这个结构上的每个节点“Object”只能通过“消息”和其他节点通讯。每个节点会有内部隐藏的状态，状态不可以被直接修改，而应该通过消息传递的方式来间接的修改。

举例说明：

> 那么为什么OOP能够支撑庞大复杂的系统呢？用开公司举个例子。如果公司就只有几个人，那么大家总是一起干活，工作可以通过“上帝视角“完全搞清楚每一个细节，于是可以制定非常清晰的、明确的流程来完成这个任务。这个思想接近于传统的[面向过程编程](https://www.zhihu.com/search?q=面向过程编程&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A550196442})。而如果公司人数变多，达到几百上千，这种“上帝视角”是完全不可行的。在这样复杂的公司里，没有一个人能搞清楚一个工作的所有细节。为此，公司要分很多个部门，每个部门相对的独立，有自己的章程，办事方法和规则等。独立性就意味着“隐藏内部状态”。比如你只能说申请让某部门按照章程办一件事，却不能说命令部门里的谁谁谁，在什么时候之前一定要办成。这些内部的细节你管不着。类似的，更高一层，公司之间也存在大量的协作关系。一个汽车供应链可能包括几千个企业，组成了一个商业网络。通过这种松散的协作关系维系的系统可以无限扩展下去，形成庞大的，复杂的系统。这就是OOP想表达的思想。

### 问题：编译型语言与解释型语言

编译型语言：c++严格的编译流程，先把代码编译成二进制可执行文件后执行；解释型语言：逐行解释成机器语言执行

其他区别：

- 效率不同：编译型一次性编译，运行效率更高。
- 可移植性：编译型语言要考虑具体的平台，而解释型语言只要安装了解释器，就可以直接运行源代码，如python。

### 问题：编译的过程

关键词: 预处理(展开`inlcude`、条件编译、宏替换等)、编译、汇编、连接

## 问题：编译时链接的两种方式的优缺点？

静态库链接、动态库链接是链接的两种方式，链接的作用是复用已写好的代码库。静态链接将用到的静态库函数代码直接copy一份到主函数程序中，主函数中拥有程序运行的完整代码；动态库则只是链接到了在主函数中做了个标记，在运行时再去找相应的函数实现代码段。根据两种链接的特点，可以总结出两种的优缺点：

静态链接：

- 优点：
  - 执行效率高：程序中有调用函数的完整代码，不需要动态链接动态库，启动调用都相对快；
  - 程序完整性：所有依赖都打包在一个可执行文件中，发布时不需要动态库文件，不需要关心系统是否缺少相应的动态库；

- 缺点：
  - 占用内存：
  - 更新维护慢：

- 使用场景：
  - 简单场景：对于**简单**的、**独立**的**小型**应用程序，静态链接是一个不错的选择。
  - 隔离性：在希望确保程序的独立性和隔离性时，静态链接可以提供更好的安全性。


动态链接：

- 优点：
  - 节省空间：多个程序可以共享同一个动态链接库，因此可以节省磁盘空间和内存消耗。
  - 更新和维护快：修改了库文件只需要重新编译库，不需要重新编译整个远程序；
  - 灵活性：动态链接库允许系统在运行时动态加载和卸载库，这使得程序更加灵活，可以根据需要加载所需的库。

- 劣势：效率比静态库连接低，主要有个动态连接的过程
- 使用场景：
  - **大型应用程序**：对于大型应用程序，**动态链接可以减小可执行文件的大小**，并允许多个进程共享库，从而节省系统资源。
  - **系统共享库**：操作系统本身通常使用动态链接，**以便在所有应用程序之间共享一组核心函数和功能**。
  - 分发软件包: 例如采用共享库来作为一个软件升级包，用户下载这个这个共享库后，替换了旧版本，应用程序运行时，会自动加载这个共享库并进行重新链接。
  - 构建高性能的Web服务器:很多Web服务器接受客户端的请求生成动态的页面内容，早期的做法是创建一个子进程(fork)，然后在这个子进程来生成动态的页面内容，这样的方式性能不是很好，不利于扩展，而高性能的Web服务器则是将每个动态生成页面内容的函数封装成一个共享库，当服务器接受到客户端请求时，会动态链接到合适的函数，然后调用它，这个函数只加载一次，便会缓存在内存中，下一次请求同一个函数时，就是直接获取这个函数指针即可，另外，如果函数发生变化时，不需要重启服务器，只需要重新加载这个共享库就可以了，另外Web服务器也可以动态增加一个新的函数，来满足新的业务需求。

**静态库的使用：**

制作：`ar rcx libxxx.a xxx.o xxx.o`

使用：`gcc main.c -o app -I (头文件路径) -L （静态库文件路径） -l 静态库名`

**动态库的使用：**

制作：

```gcc -c  -fpic xx1.c xx2.c```

`gcc -share xx1.o xx2.o -o libcalc`

使用：`gcc main.c -o app -I (头文件路径) -L （静态库文件路径） -l (静态库名)`

## 问题：linux可执行程序的加载过程

了解ELF文件（不可重定向文件）的结构：

- 程序头部表负责将可执行文件中连续的内容映射到连续的内存段。
- 节头表代表每一节的在文件中的偏移地址和大小等信息
- 每一节的含义。。。

**可执行文件的加载**:

当你通过`./prog` 命令（`prog`是可执行文件的名称）加载一个可执行文件，当执行这个命令时，操作系统会调用内核中的一个**加载器(loader)**，通过加载器来运行可执行文件，另外在[Linux](https://so.csdn.net/so/search?q=Linux&spm=1001.2101.3001.7020)中也可以采用`execve`函数来调用加载器。

**加载器加载的过程**：

- 申请进程描述符：创建**PCB**并进行初始化(初始化进程标识符、**进程资源**和进程虚拟地址空间；)
- 虚拟内存映射：建立可执行文件的内容(按照页大小)和虚拟地址空间页的映射关系**(依据程序头部表)**；
- 将可执行文件的文件头信息加载到内存；

以上就是加载一个可执行文件的过程，可以看出**加载的过程并没有把可执行文件中的代码和数据加载到内存**，当CPU第一次调度进程时，加载器才会**根据文件头中的程序入口地址**，开始执行第一条指令，当执行这条指令时，发现指令不在内存中，发生了**缺页中断**，才会将虚拟页加载到内存中。

程序的入口地址往往指向`_start函数`，`_start函数`调用系统启动函数`__libc_start_main`，这个系统启动函数定义在`libc.so`中，它负责初始化执行环境,调用用户层提供的main函数,同时负责处理main函数的返回值，并在合适的时机交由内核处理。

参考资源：[彻底搞懂程序链接过程之动态链接_动态链接 原理_一口Linux的博客-CSDN博客](https://blog.csdn.net/daocaokafei/article/details/118614187)

# C++基础

## 关键字

### 问题: 指针与引用的区别

- 指针是种特殊的变量；引用是个别名，实质上是个指针常量，所以引用必须被初始化，而指针可以是`NULL`,之后可以被赋值；
- 使用指针的访问数据的时候需要解引用，而引用直接代表数据本身；
- 作用：指针做函数参数时，改变指针指向不改变原指针，而引用做函数参数时，改变引用相当于改变引用指向的数据的值；

### 问题：函数调用时什么时候使用指针？什么时候使用引用？

看你的目的，分为使用函数读和使用函数写：

- 使用函数读的时候
  - 如果数据对象很小，如内置数据类型或者小型结构，则按照值传递；
  - 如果数据对象是较大的结构，则使用const指针或者引用，已提高程序的效率。这样可以节省结构所需的时间和空间；
  - 如果数据对象是类对象，则使用const引用；
  - 如果数据对象是数组，则使用指针（唯一的选择），并且指针声明为指向const的指针；
- 使用函数写：
  - 如果数据是内置数据类型，则使用指针
  - 如果数据对象是数组，则只能使用指针
  - 如果数据对象是结构，则使用引用或者指针
  - 如果数据是类对象，则使用引用

### 问题：数组名与指针的关系(数组名与指针完全等价吗)？

数组名和指针表现相同的点：

- 偏移随机读取：二者均可通过增减偏移量来访问数组中的元素；

通过偏移随机读取的特点，很多人会误以为两者是等价的，但是在很多情况下两者还是有明显区别的，区别如下：

- 数组名是常指针：**数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。**
- `sizeof()`结果不一样: 使用`sizeof(数组名)`返回的是数组的大小；

注意点：

- 数组名传参后不再是数组名：当数组名当做**实参传递给调用函数形参后，就失去了原有特性**，退化成一般指针，多了自增、自减操作，但`sizeof`运算符不能再得到原数组的大小了

### 问题：```const```作用

关键词：类外(变量、指针、函数参数、函数返回值(和引用一起))、类中：成员变量(必须通过初始化成员列表初始化)、成员函数

修饰指针：

`const int *p = &a;` //常量指针

`const int *p = &a;` //指针常量

修饰函数返回值：

- 编译优化： 如果返回的是类对象而不是指针或引用，将返回值声明为`const`可以防止在返回时进行不必要的复制。因为在返回一个`const`对象时，编译器通常会优化掉复制构造函数的调用，从而提高性能。

- （配合引用）表示该返回值不能被修改

```c++
class MyClass {
public:
	MyClass(int val) : value(val) {}

	int getValue() const {
		return value;
	}

	// 返回值为const类型
	const int& getValueRef() const {
		return value;
	}

private:
	int value;
};


int main() {
	const MyClass obj(5);  // 声明一个const对象
	std::cout << "Value: " << obj.getValue() << std::endl;

	// 使用const成员函数返回的const引用
	const int& valueRef = obj.getValueRef();
	std::cout << "Value from reference: " << valueRef << std::endl;

	return 0;
}
```

修饰成员函数：

- 本质： 相当于修饰了this指针，所以`const`不能用于修饰`static`成员函数\友元函数；
- 想要修改`const`成员函数中某些与类状态⽆关的数据成员，可以使⽤`mutable`关键字来修饰这个数据成员；

```C++
#include <iostream>

class Example {
public:
    Example(int val) : value(val) {}

    int getValue() const {
        return value;
    }

    void increment() const {
        mutableValue++;  // 修改被 mutable 修饰的成员变量
    }

private:
    int value;
    mutable int mutableValue = 0;  // 用 mutable 修饰的成员变量
};

int main() {
    Example obj(5);
    std::cout << "Initial value: " << obj.getValue() << std::endl;

    obj.increment();  // 在 const 成员函数中修改 mutable 成员变量
    std::cout << "Value after increment: " << obj.getValue() << std::endl;

    return 0;
}

```



#### 问题：```const```和```constexpr```

```const```用于声明常量，但会出现双重语义：只读(修饰形参时)与常量; ```constexpr```用于声明常量表达式，它可以用于在编译时计算的上下文中，表示**其申明的表达式的结果在编译时就能确定**。编译器在编译程序时可以顺带将其结果计算出来，而无需等到程序运行阶段，这样的优化极大地提高了程序的执行效率。

> C++ 11标准中，为了解决``` const ```关键字的双重语义问题，保留了 `const `表示“只读”的语义，而将“常量”的语义划分给了新添加的 `constexpr `关键字。因此 C++11 标准中，建议将 `const` 和 `constexpr` 的功能区分开，即凡是表达“只读”语义的场景都使用 const，表达“常量”语义的场景都使用` constexpr`。在大部分实际场景中，`const` 和` constexpr` 是可以混用的。
>

`constexpr` 可以用于变量、函数、构造函数等当使用`constexpr`修饰构造函数, 应该满足：

1. 构造函数的函数体必须是一个返回结果可以在编译时计算的表达式。
2. 构造函数的参数必须是常量表达式。

```c++
class Circle {
public:
	constexpr Circle(double r) : radius(r) {}
	
	constexpr double getRadius() const {
        return radius;
    }
}

int main() {
    constexpr Circle c(5.0);  // 使用constexpr构造函数创建常量表达式对象
    std::cout << "Circle radius: " << c.getRadius() << std::endl;
    return 0;
}
```

`constexpr`关键字在使用时有一些限制：

- **表达式必须在能够在编译时求值**：`constexpr`表达式必须在编译时就能被求值出结果，不能包含运行时的计算、输入或输出等操作。
- **局部变量初始化限制**：在C++11中，局部变量的初始化只能使用常量表达式。在C++14中，对于一些简单的初始化，限制得到了放宽。
- **函数体限制**：在C++11中，`constexpr`函数的函数体非常有限，不能包含**循环**、**递归函数调用**、**非常量全局变量**等。在C++14中，一些简单的循环和控制流被允许在`constexpr`函数体中使用。

参考资料：[C++11 constexpr和const的区别详解 (biancheng.net)](http://c.biancheng.net/view/7807.html)

#### 问题：指针常量和常量指针

指针常量(顶层const)：```int* const p;```

常量指针(底层const)：```const int* p;```

### 问题：`inline`

用于修饰函数，请求编译器在调用此函函数时直接替换为函数内的代码，避免了函数调用的开销，提高程序的运行效率，但是并不是所有的函数都能被内联。

>  虚函数不能再是内联的函数，因为内联函数在编译阶段进行替代，而虚函数表示等待，在运行阶段才能确定到低是采用哪种函数，虚函数不能是内联函数.

### 问题:  ` static`

static用于声明静态变量，主要有以下使用场景

- 不考虑类的情况
  - 对于**全局变量**来说：限制其的作用域，其仅作用于当前文件
  - 对于**局部变量**来说：增长了其的生命周期，从程序开始时到结束。所以静态变量在函数内定义，始终存在，且只进行一次初始化，具有记忆性，其作用范围与局部变量相同，函数退出后仍然存在，但不能使用；
  - 默认初始化为0，包括未初始化的全局静态变量与局部静态变量，都存在全局未初始化区；
  - **静态局部**变量在C++11后是线程安全的，可以用来设计线程安全的单例模式。
- 考虑类的情况
  - static成员变量：只与类关联，不与类的对象关联。**定义了static成员变量的类，需要在类定义体外部初始化**，初始化时不需要标示为static；**可以被非static成员函数任意访问*;*
  - static成员函数：不具有this指针，无法访问类对象的非static成员变量和非static成员函数；**不能被声明为`const`、虚函数和`volatile`**；可以被非static成员函数任意访问
- 静态变量的初始化时机：
  - c语言中：**初始化发生在代码执行**之前，编译阶段分配好内存之后，就会进行初始化，所以我们看到在C语言中**无法使用变量对静态局部变量进行初始化**，在程序运行结束，变量所处的全局内存会被全部回收；
  - C++语言中：初始化时在执行相关代码时才会进行初始化，主要是由于C++引入对象后，要进行初始化必须执行相应构造函数和析构函数，在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。
  - 类的静态变量必须初始化，因为其在类被定义后就存在了。

### 问题：extern ‘C’

>  `extern "C"`这个关键字最主要的目的就是实现C和C++的混合编程，虽然说C++是兼容C语言的语法的，但是C++编译器和C编译器在编译的C语法的时候还是有些区别的，如编译函数(C++为了支持函数重载，会将 `func(int, int )`的函数名编译成`_func_int_int`)、编译变量(同样在编译类中变量时C++也有特殊的处理)、链接；如果这时候A模块是用c写的，B模块是用C++写的，B去引用A模块的函数，就会出现连接错误，因为会出现找不到函数的情况，所以C++需要通过一个东西来告诉C++编译器其引用的是C语言编译的模块，要按C语言编译的特性去连接。

此外，extern说明的声明外部变量和函数用的，相当于只会在extern ‘C’修饰的部分都是外部的.

参考资料：[关于 C++ 中的 extern "C" - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/123269132)

### 问题: C++的四种强制转换reinterpret_cast/const_cast/static_cast /dynamic_cast

- 静态类型转换：`static_cast`

  - 默认隐式转换的都可以用static_cast进行显示转换，能忽略一些警告，所以需要自己确认安全性；

  - 语法示例 `static_cast<int> (floatdata);`

  - 应用场景

    - 用于类层次结构中，父类和子类之间指针和引用的转换；子类指针转成父类指针，安全的；父类指针转向子类指针，不安全；

    - 用于基本数据类型之间的转换，例如把`int`转`char`，`int`转`enum`等，需要编写程序时来确认安全性；

    - 把`void*`指针转换成目标类型的指针（转换错误是极其不安全的）；

- 重新解释类型转换：`reinterpreter_cast`

  - 指针类型的重新解释：如```int* p = &a```; 指针赋值给用`char* pc = reinterpret_cast<char*> p;`。这是一种比较危险的操作，需要时刻牢记pc指向的真实对象是int.

- 动态类型转换：`dynamic_cast`

  - 运用与父类指针到子类对象的转化，可以用于判别对象的实际类型。`dynamic_cast`转换若成功，返回的是指向类的指针或引用；若失败则会返回`NULL`。

  - 在类的转换时，在类层次间进行上行转换时，`dynamic_cast`和`static_cast`的效果是一样的。

  - 在进行下行转换时，`dynamic_cast`具有类型检查的功能，比static_cast更安全。

- 去`const`属性 : `const_cast`([强制类型转换(const_cast) - kaizenly - 博客园 (cnblogs.com)](https://www.cnblogs.com/Braveliu/p/3616953.html))

  - 去掉常对象的`const`属性，可以对对象自由写入;

  - 注意点：如果对象本身是个不可写的常量，不可进行`const`转换.

    ![img](https://api2.mubu.com/v3/document_image/c6639766-d71f-4298-94d1-d3e872352ec7-24309411.jpg)

- 转换原则：无论什么转换，要清楚的知道类型转换前是什么类型，转换后是什么类型。转换后有什么后果。

- 通用语法：cast-name<type>(expression)

### 问题：volatile

作用：volatile是一个类型修饰符（type specifier），它是被设计用来**修饰被不同线程访问和修改的变量**。volatile关键字影响编译器编译的结果，用volatile声明的变量表示该变量随时可能发生变化，与该变量有关的运算，不要进行编译优化，以免出错。所以一般Volatile修饰的变量 都是 直接存取原始内存地址。

深入了解原因*：如果没有volatile，基本上会导致这样的结果：要么无法编写多线程程序，要么编译器失去大量优化的机会。Volatile意思是“易变的”，应该解释为“**直接存取原始内存地址**”比较合适。“易变”是因为外在因素引起的，像多线程，中断等。

参考：[C语言丨深入理解volatile关键字 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/343688629)

## 函数

### 问题：函数重载的规则与匹配规则

函数重载意义：一个函数可以有多种调用方式，实现静态多态。

函数重载规则:

>  函数重载只发生在在**同一作用范围定义了多个同名成员函数**。主要特点是**函数名相同**，函数参数列表不同(具体指参数类型、数目、次序有所不同**)，返回值类型不能作为函数重载的依据。重载和函数成员是否是虚函数无关。

重载函数的匹配机制：

> 第一步: 确定候选函数集：同一命名空间，同一作用域下的同名函数集合；
>
> 第二步: 确定可行函数集
>
> 可行函数特征：
>
> - 最低标准：实参个数与被调用函数所需形参个数相同。
> - 类型相同：每个实参的类型要与对应的形参类型相同,**或者是能够转换成形参的类型**，意味着通过隐式转换后能匹配的也算可行函数。
>
> 如果没找到可行函数集，编译器就会报没有相应匹配函数的错误
>
> 第三步：寻找最优匹配
>
> 如果存在多个可行函数，则需从中找到最佳匹配，最佳匹配原则：根据实参的匹配个数来定，匹配选择匹配个数最多的。如果有多个最优的则报错。

代码示例：

```c++
#include <iostream>
using namespace std;

void print(int a, int b, double c) {
	cout << a << b << c << endl;
}

void print(int a, int b, float c) {
	cout << a << b << c << endl;
}

void print(int a, int b, int c) {   // int int int 最佳匹配
	cout << a << b << c << endl;
}

// 如果去掉了第三个重载函数printiii，那就不存在两个最佳匹配，产生二义性。
int main() {
	int a = 1;
	int b = 2;
	int c = 3;
	print(1, 2, 3);
	return 0;
}
```

### 问题：重载与重写与隐藏的区别？

重载如上个问题所示，用于在**同一作用域**下实现一个**同名函数**的多种调用。

重写：重写则指在派生类中**重写父类的同名虚函数**(用于实现多态)且重写函数需满足以下要求：

- 与基类的虚函数有相同的参数个数
- 与基类的虚函数有相同的参数类型
- 与基类的虚函数有相同的返回值类型

隐藏：**普通的父类同名函数重写**仅仅起到隐藏父类同名函数的作用，不需要满足参数相同以及返回值相同等要求。

重载和重写的区别：

- 重写是父类和子类之间的**垂直关系**，重载是不同函数之间的**水平关系**；
- 重写要求相同参数列表和返回值，重载则要求 同名函数不同参数列表，返回值不要求；
- 重写关系的同名函数中，调用方法根据对象类型决定，重载根据调用时实参表与形参表的匹配关系来选择调用函数

### 问题：函数调用时使用值传递、指针传递、引用传递有啥区别？

1. 值传递：有一个形参向函数所属的栈拷贝数据的过程，**如果值传递的对象是类对象 或是大的结构体对象，将耗费一定的时间和空间**。（传值）
2. 指针传递：**同样有一个形参向函数所属的栈拷贝数据的过程，但拷贝的数据是一个固定为4字节的地址**。（传值，传递的是地址值）
3. 引用传递：同样有上述的数据拷贝过程，但其是针对地址的，相当于为该数据所在的地址起了一个别名。（传地址）
4. 效率上讲，指针传递和引用传递比值传递效率高, 所以一般对于结构体变量或者类对象都主张使用指针或引用。在函数调用上，引用一般都可以替代使用指针，且使用更加简单。除了个别情况不能替代外。

### 问题：函数调用时栈的变化

简单来说有以下几点：

1. ebp和esp寄存器分别存放着当前栈帧的基地址和栈顶地址；
2. 函数调用时，会将 上个栈帧的基地址 压入栈中，并开辟新的栈帧基地址，栈顶地址；
3. 之后会在栈基地址固定的偏移位置上初始化形参，返回地址等；
4. 函数调用结束后 弹出上一栈帧的基地址 到ebp。

按指针传递：

![image-20230824141450736](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230824141450736.png)

参考博客：

[函数调用时栈是如何变化的？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/446344416)

[函数调用时程序堆栈的变化_函数调用堆栈变化_fang92的博客-CSDN博客](https://blog.csdn.net/fang92/article/details/46494665)

#### 问题：函数指针

函数指针是一种特殊的指针，用来指向函数，主要的作用就是通过函数指针做为函数参数实现函数的回调，根据传的实参展示出不同的功能。

一个函数地址是该函数的进入点，也就是调用函数的地址。函数的调用可以通过函数名，也可以通过指向函数的指针来调用。函数指针还允许将函数作为变元传递给其他函数；

函数指针定义：

`int (*pf)(const int&, const int&); `

## 宏相关

### 问题：宏定义和函数的区别

宏定义制作简单的类型替换，并不存在函数调用过程，也就是说函数的调用的类型检查、跳转、返回值宏定义都没有；

### 问题：宏定义与```typedef```的区别

- 原理不一样：宏定义只是做代码替换的，typedef是**给已知数据类型取别名**的；
- 编译时被处理的阶段不一样：宏在预处理阶段被处理，typedef则在编译的时候被处理；
- 类型检测：宏不会、后者会;
- 作用域不同，`#define`没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。而typedef有自己的作用域。
- 注意对指针的操作，```typedef char * p_char```和```#define p_char char *```区别巨大；

```C++
typedef char* PCHAR;
unsigned PCHAR pc; //语法错误

#define PCHAR char *
unsigned PCAHR pc; // 编译通过
// 因为宏定义在预处理时全部被替换，所以unsigned PCAHR pc;会被替换成unsigned char *pc;

typedef char* PCHAR;
PCHAR pa,pb;
// pa,pb都是字符指针类型

#define PCHAR char *
PCHAR pa,pb;
// PCHAR pa,pb;会被翻译成char *pa,pb;
// 这导致pa是字符指针类型，而pb是字符类型
```

### 宏定义和```const```的差别？

两者都是定义常量的方式，```const```主要被设计出来替代宏常量的，主要有以下差别:

- 1、编译过程中被处理阶段不一样的不同
- 2、有无类型检查(安全性)；
- 3、内存耗损不同：define只是将宏名称进行替换，在内存中会产生多分相同的备份。```const```在程序运行中只有一份备份，且可以执行常量折叠，能将复杂的的表达式计算出结果放入常量表
- 4、**其他，C++默认将```const```变量藏于符号表，不直接分配内存，效率更高；取地址的时候才分**;
- 作用域：```const```和```define```默认作用于当个文件、```const```变量可以配合```extern```关键字在多个文件中使用

### 问题：宏定义和内联函数(inline)的区别

两者都可以用来将函数替换成函数内代码片段，但主要有以下差别:

1. 处理阶段不同：宏定义在预处理阶段进行文本替换，`inline`函数在编译阶段进行替换；
2. 类型检查：`inline`保持函数的特性，有类型检查，更加安全；
3. 内存耗损不同：define只是将宏名称进行替换，在内存中会产生多分相同的备份。```const```在程序运行中只有一份备份，且可以执行常量折叠，能将复杂的的表达式计算出结果放入常量表

## 面向对象

## 问题：封装

封装有两层含义：

- 封装对象属性和方法（成员函数和成员变量）
- 访问控制(对外屏蔽细节、只提供可用接口)

### 问题：stuct 和 class 的不同点

- **默认访问控制不同**：两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的
- **默认继承方式不同**：class默认是private继承， 而struct默认是public继承

###  特殊的成员函数问题

#### 问题： 有几种构造函数？

无参、有参、拷贝、**移动拷贝**。

#### 问题：构造函数与初始化成员列表

初始化成员列表：用于类中的变量、对象的初始化以及父类的初始化;

初始化列表执行顺序：

- 列表中顺序是**由类中的成员声明顺序决定**的，不是由初始化列表的顺序决定的；

- 编译器会一一操作初始化列表，以适当的顺序在构造函数之内安插初始化操作，并且在任何显示用户代码之前；

为什么用成员初始化列表会快一些？

> 不使用初始化成员列表是在构造函数当中做赋值的操作，而使用初始化成员列表是做纯粹的初始化操作。总的来说，不使用会 多一步赋值操作而且会产生临时对象，临时对象的创建和销毁会降低程序的效率.

什么时候必须使用？

- 初始化一个```const```常量成员时*（引用）
- 当调用一个基类的构造函数，而它拥有一组参数时；
- 当调用一个成员类的构造函数，而它拥有一组参数时；

#### 问题：构造函数和析构函数能不能抛出异常？

能，但不推荐，会引发错误，比如资源没有被释放等。如下代码会运行时出错：

```c++
#include <iostream>
using namespace std;


class Ahua {
public:
	Ahua(){
		a = new char[10];
	}
	~Ahua() {
		int i = 1;
		throw i;
		delete[] a;
	};

public:
	char* a;
};

int main() {

	try {
		Ahua h;
		h.~Ahua();
	}
	catch (int) {
		cout << "出错了" << endl;
	}
	return 0;
}
```

#### 问题：拷贝构造一定要传引用为什么？

1. 拷贝构造函数的作用就是用来复制对象的，在使用这个对象的实例来初始化这个对象的一个新的实例。
2. 参数传递过程到底发生了什么？ 将地址传递和值传递统一起来，归根结底还是传递的是"值"(地址也是值，只不过通过它可以找到另一个值)！ **按值传递**: 对于内置数据类型的传递时，直接赋值拷贝给形参(注意形参是函数内局部变量)； **对于类型的传递时，需要首先调用该类的拷贝构造函数来初始化形参(局部对象)；**

所以如果按值传的话，实参向形参拷贝时会不断调用拷贝构造，造成堆栈溢出。

#### 问题：浅拷贝和深拷贝的区别

在类中有指针成员时需要注意**拷贝构造**和**赋值函数**的深浅拷贝问题：

- 浅拷贝：按值拷贝，不管是普通变量还是指针变量。这就意味着如果对象中含有指针的话拷贝后会出现两个指针指向同一个内存的情况，就可能导致析构时同时是释放的问题，需要避免；
- 深拷贝：对普通变量按值拷贝，对于指针变量会**创建一块新内存**复制原对象中指针指向的数据。

#### 问题：操作符重载

查看笔记：https://note.youdao.com/s/bqOLxMDa

## 问题：继承的作用？与继承后的访问控制？

继承：继承就是一个类继承了另一个类的属性和方法(并非所有，如构造函数就不会被继承)，这个新的类包含了上一个类的属性和方法，被称为子类或者派生类，被继承的类称为父类或者基类；

访问控制的继承：分三种情况答

**继承的兼容性原则**：子类可以被当做父类用，实现多态的关键

####  问题：菱形继承与虚继承

菱形继承如下：

```cpp
#include <iostream>
using namespace std;

class A{}
class B : virtual public A{};
class C : virtual public A{};
class D : public B, public C{};

int main()
{
    cout << "sizeof(A)：" << sizeof A <<endl; // 1，空对象，只有一个占位
    cout << "sizeof(B)：" << sizeof B <<endl; // 4，一个bptr指针，省去占位,不需要对齐
    cout << "sizeof(C)：" << sizeof C <<endl; // 4，一个bptr指针，省去占位,不需要对齐
    cout << "sizeof(D)：" << sizeof D <<endl; // 8，两个bptr，省去占位,不需要对齐
}
```

菱形继承会导致孙子类中有多个爷爷类的对象，**虚拟继承的情况下，无论基类被继承多少次，只会存在一个实体**。

虚拟继承基类的子类中，子类会增加某种形式的指针，或者指向虚基类子对象，或者指向一个相关的表格；表格中存放的不是虚基类子对象的地址，就是其偏移量，此类指针被称为`bptr`.

## 多态与虚函数

多态的实现效果：同样的调用语句在不同父类和子类间穿梭的时候表现出不同的调用效果。

多态的成立条件：继承、虚函数重写、父类指针指向子类对象

多态的C++的实现：`vitual`关键字，相当于告诉编译器这个函数需要支持多态，不要根据对象的静态类型(声明时的类型)进行绑定，应该根据指针的所指向的实际对象来判断如何调用。这其中涉及中了**动态联编和静态联编！**

多态技术的意义：多态对于C++的程序设计用着重要的意义，是面向抽象类编程的基础、是设计模式的基础。

多态(动态联编)的原理：编译器提前布局了虚函数表与`vptr`指针，通过`vptr`去找虚函数表，虚函数表找到函数的地址，实现动态的绑定，具体过程如下：

- 编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，**该表是一个一维数组**，位于常量区，虚表里保存了虚函数的入口地址；
- **编译器会在每个对象的前四个字节中保存一个虚表指针，即`vptr`**，指向对象所属类的虚表。在构造时，根据对象的类型去初始化虚指针`vptr`，从而让`vptr`指向正确的虚表，从而在调用虚函数时，能找到正确的函数；
- 所谓的合适时机，在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。在构造子类对象时，会先调用父类的构造函数，此时，编译器只“看到了”父类，并为父类对象初始化虚表指针，令它指向父类的虚表；当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表；
- 当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加在后面。

### 问题：虚函数？虚函数表？含有虚函数的类的内存布局？

>  首先整理一下虚函数表的特征：
>
> - 虚函数表是全局共享的元素，即全局仅有一个，在编译时就构造完成
> - 虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表，即虚函数表不是函数，不是程序代码，不可能存储在代码段
> - 虚函数表存储虚函数的地址,即虚函数表的元素是指向类成员函数的指针,而类中虚函数的个数在编译时期可以确定，即虚函数表的大小可以确定,即大小是在编译时期确定的，不必动态分配内存空间存储虚函数表，所以不在堆中;

> 综上所述： C++中 虚函数表位于只读数据段（.rodata），也就是C++内存模型中的**常量区**；而虚函数则位于代码段（.text），也就是C++内存模型中的代码区。

### 问题：虚函数相关

是不是所有的函数都设置成虚函数比较好？

> 不是，虚函数调用需要两步，效率不高，对于不需要展现多态的函数就不用使用多态;

析构函数一定要设置成虚函数的原因：

> 防止子类对象析构不完全：如果析构函数不被声明成虚函数，则编译器实施静态绑定，**在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数**，这样就会造成派生类对象析构不完全，造成内存泄漏。而且：
>
> - **析构函数可以是纯虚函数**，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。

构造函数不能是虚函数的原因：

> 虚函数对应一个`vtable`(虚函数表)，类中存储一个`vptr`指向这个`vtable`。如果构造函数是虚函数，就需要通过`vtable`调用，**可是对象没有初始化就没有`vptr`**，无法找到`vtable`，所以构造函数不能是虚函数。

构造和虚构函数调用虚函数？虽然可以，但是没有意义，根本不会走虚函数表。

> 此外，能不能在构造或析构函数中调用虚函数呢？根据《effective C++》的条款09：绝不在构造和析构过程中调用虚函数，在构造函数中虽然可以调用虚函数，但是强烈建议不要这样做。因为基类的构造的过程中，虚函数不能算作是虚函数。若构造函数中调用虚函数，可能会导致不确定行为的发生.

### 问题：哪些函数不能是虚函数？

1. 构造函数，构造函数初始化对象，派生类必须知道基类函数干了什么，才能进行构造；当有虚函数时，每一个类有一个虚表，每一个对象有一个虚表指针，虚表指针在构造函数中初始化；
2. 内联函数，内联函数表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间进行类型确定，所以内联函数不能是虚函数；
3. 静态函数，静态函数不属于对象属于类，静态成员函数没有this指针，因此静态函数设置为虚函数没有任何意义。
4. 友元函数，友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。
5. 普通函数，普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数。

### 问题：其他多态技术

静态型多态(编译时确定)：函数重载、函数模板

### 问题：RTTI技术

> RTTI，即**Run-Time Type Identification**运行时类型认定，通过运行时类型信息程序能够使用父类的指针或引用来检查这些指针或引用所指的对象的实际派生类型，是多态实现的技术基础。 

### 问题：抽象类

抽象类的定义: 定义了纯虚函数的类称为抽象类，抽象类不能被实例化，且在子类中需要对纯虚函数进行重写(否则子类也是纯虚函数)，**纯虚函数并没有具体的函数体，所以其虚函数表中的值就为0，而具有函数体的虚函数则是函数的具体地址**。

抽象类的**使用场景**：

- **定义接口：** 抽象类可以用来定义接口，即一组纯虚函数（只有函数声明而没有实现）。其他类可以继承这个抽象类并实现其中的纯虚函数，从而确保派生类都具有一致的接口。这种机制使得多态性和多重继承更加灵活可控；
- **约束继承关系：** 抽象类可以约束其派生类必须实现某些方法，这样可以确保派生类具有特定的行为。抽象类起到了规范和限制派生类行为的作用，减少了设计时的不一致性；
- **框架和库设计：** 在设计框架、库或模块时，抽象类可以用来定义框架的核心接口和基础功能。使用者可以基于这些抽象类创建具体的子类，实现特定的功能。

## 泛型编程

### 问题：模板是怎么实现的？

(二次编译，根据模板实例生成处理不同类型的函数)

编译器会对模板进行**两次编译**：在声明的地方对模板代码本身进行编译，**在调用的地方对模板参数替换后的代码进行编译**。所以，**编译器并不是把函数模板处理成能够处理任意数据类型的函数**，而是通过具体类型来产生不同的函数；

### 问题：为什么类模板一般放在一个文件里？

普通函数编译时：假设`main.cpp`中调用`include`了  `test.cpp`的头文件，f函数的定义在`test.cpp`，那么mai函数在编译时是这样的：

>  编译`main.cpp`时，编译器不知道f的实现，所以当碰到对它的调用时只是给出一个指示，指示连接器应该为它寻找f的实现体。**这也就是说`main.obj`中没有关于f的任何一行二进制代码**。
>
> 编译`test.cpp`时，编译器找到了f的实现。于是乎f的实现（二进制代码）出现在`test.obj`里。
>
> 链接时，链接器在`test.obj`中找到f的实现代码（二进制）的地址（通过符号导出表）。然后将`main.obj`中悬而未决的`call XXX`地址改成f实际的地址（分为静态链接和动态链接）。

类模板编译时：**模板是通过二次编译实现的，第一次只编译模板相关的代码，直到遇到模板实例才会去二次编译类模板中的代码**。如果将模板的定义和实现分开写，会出现二次编译时不进行编译，只负责给出一个指示，告诉编译器这个地方并没有实现，可能在其他文件中，链接的时候帮我找找，而单独编译模板实现的文件并不会触发二次编译，因为文件中没有相应的实例，导致无法编译实例化的模板，最终导致找不到相应的函数，出现链接错误。

参考资料：[c++ 模板类 声明和定义都放在.h文件的原因_为什么模板类一般都是放在一个h文件中_lijiayu2015的博客-CSDN博客](https://blog.csdn.net/lijiayu2015/article/details/52650790)

### 问题：模板的特化与偏特化

作用：模板分为类模板和函数模板，特化分为特例化(全特化)和部分特例化（偏特化），**对模板的特例化是因为对特定数据类型，可以利用某些特定的知识来提高实现效率(具体可以看STL中的哈希函数的偏特化)，而不是使用通用模板**。

函数模板的特化与偏特化：
1. 模板和特例化版本应该声明在同⼀头⽂件，所有同名模板的声明应放在前⾯，接着是特例化版本。 
2. ⼀个模板被称为全特化的条件：1.必须有⼀个主模板类  2.**模板类型被全部明确化**。 

类模板：
对主版本模板类、全特化类、偏特化类的调⽤优先级从⾼到低进⾏排序是：全特化类>偏特化类>主版本模板类

使用示例：

1、函数模板特例化

```C++
template<typename T> //模板函数
int compare(const T &v1,const T &v2)
{
    if(v1 > v2) return -1;
    if(v2 > v1) return 1;
    return 0;
}
//模板特例化,满足针对字符串特定的比较，要提供所有实参，这里只有一个T
template<> 
int compare(const char* const &v1,const char* const &v2)
{
    return strcmp(p1,p2);
}
```

2、类模板特例化

```c++
template<>
class hash<sales_data>
{
	size_t operator()(sales_data& s);
	//里面所有T都换成特例化类型版本sales_data
	//按照最佳匹配原则，若T != sales_data，就用普通类模板，否则，就使用含有特定功能的特例化版本。
};

```

3、特例类模板的某个函数

```c++
template<typename T>
class Foo
{
    void Bar();
    void Barst(T a)();
};

template<>
void Foo<int>::Bar()
{
    //进行int类型的特例化处理
    cout << "我是int型特例化" << endl;
}

Foo<string> fs;
Foo<int> fi;//使用特例化
fs.Bar();//使用的是普通模板，即Foo<string>::Bar()
fi.Bar();//特例化版本，执行Foo<int>::Bar()
//Foo<string>::Bar()和Foo<int>::Bar()功能不同
```

注意点：

**特例化的本质是实例化一个模板，而非重载它**。特例化不影响参数匹配。参数匹配都以最佳匹配为原则。例如，此处如果是`compare(3,5)`，则调用普通的模板，若为`compare(“hi”,”haha”)`则调用**特例化版本**（因为这个`cosnt char*`相对于T，更匹配实参类型），注意二者函数体的语句不一样了，实现不同功能。

# `STL`相关

## 问题：`STL`是什么？六大组件？

`STL`是C++的标准模板库,实现了容器和对应的操作算法，且几乎所有的代码都用了模板类和模板函数的方式 。

`STL`的好处：

- `STL` 具有高可重用性，**高性能**，高移植性， 跨平台的  ；
- `STL` 的一个重要特点是数据结构和算法的分离，算法通过迭代器实现支持任何容器 ;

六大组件：

容器、算法、迭代器、适配器(bind, 可以改变函数的行为，原理无非就是包装)、仿函数（辅助算法使用的）、空间配置器(`alloctor`，一级配置和二级配置器)

## 问题：空间配置器？

## 容器

容器主要分为序列（关联）型容器和非序列（非关联）型容器。

- 关联型容器：每个元素的位置取决于插入时机和位置，和元素值无关 。例如：`vector`、 `dequeue`、 `list`  。
- 非关联型容器：元素位置取决于特定的排序准则，和插入顺序无关 ， 如`set`、 `multiset`、 `map`、 `multimap`

### 问题：vector

vector是一种序列式容器，其元素的组织与元素的插入顺序有关，支持随机存储。可以认为是数组，支持随机存取，访问速度快(O(1))，插入效率低(O(N))。

vector的实现原理？

本质就是数组(线性表)，一块连续的内存空间. 通过三个指针(迭代器来管理)，可以实现自动扩容。

#### 问题： vector的扩容机制？

1. 扩容机制：

**当向vector中插入元素时**，如果元素有效个数size与空间容量capacity相等时，vector内部会触发扩容机制：

- **开辟新空间**；

- 拷贝元素；
- 释放旧空间。

2. 如何避免扩容导致效率低？

如果要避免扩容而导致程序效率过低问题，其实非常简单：**如果在插入之前，可以预估vector存储元素的个数，提前将底层容量开辟好即可。**如果插入之前进行`reserve`，只要空间给足，则插入时不会扩容，如果没有`reserve`，则会边插入边扩容，效率极其低下。

3.  为啥以倍数的方式进行扩容？

- 以等长方式进行扩容的话，连续`push_back()`n个元素的时间复杂度是`O（n）`；
- 以倍数方式进行扩容的话，连续`push_back()`n个元素的时间复杂度是`O（1）`， 效率比等长扩容高。
- 详细推导看参考资料：

4. 扩容因子为什么选择2？3和4可不可以？

关键词：内存空间资源复用与资源的使用；

扩容原理为：申请新空间，拷贝元素，释放旧空间，**理想的分配方案是在第N次扩容时如果能复用之前N-1次释放的空间就太好了，**如果按照2倍方式扩容，可以看到，**每次扩容时，前面释放的空间都不能使用**。所以如果倍数超过2倍(包含2倍)方式扩容会存在：

- 空间浪费可能会比较高，比如：扩容后申请了64个空间，但只存了33个元素，有接近一半的空间没有使用。
- 无法使用到前面已释放的内存。

但是如果按照小于2倍方式扩容，多次扩容之后就可以复用之前释放的空间了。

<font color=red>**因为STL标准并没有严格说明需要按何种方式进行扩容，因此不同的实现厂商都是按照自己的方式扩容的，即：linux下是按照2倍的方式扩容的，而vs下是按照1.5倍的方式扩容的。**</font>

参考资料：[面试题：C++vector的动态扩容，为何是1.5倍或者是2倍_vector扩容_森明帮大于黑虎帮的博客-CSDN博客](https://blog.csdn.net/qq_44918090/article/details/120583540)

### 问题：list(双向链表)

vector是一种序列式容器，其元素的组织与元素的插入顺序有关，用于顺序存储(组织)元素，本质就是双向链表，支持前向遍历和反向遍历，支持快速插入和删除。

### 问题：`deque`以及栈、堆

`deque`是一中连续的数组，但支持快速从数组头部、尾部进行快速插入删除(O（1）)，其本质是一种分段连续的数据结构，如图所示：

![deque的数据结构](https://cdn.jsdelivr.net/gh/powerjeho/pic/deque%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png)

其通过一个map来管理槽，每个槽都指向一个独立的连续内存块，其迭代器是当前槽的位置以及在槽中的起始位置和当前位置。

### AVL树

二叉排序树的最大问题就是搜索的时间复杂度最坏是O（n）,所以提出了平衡二叉搜索树，在插入的过程中保持平衡。

### 问题：红黑树

红黑树是一种特殊的**平衡二叉排序树**，红黑树需要满足以下特性：

- 每个节点不是红色就是黑色；
- 根结点为黑色；
- 如果节点为红色，其子节点必为黑色；
- 任一节点至（NULL）树尾端的任何路径，所含的黑节点数量必相同。

### 问题：set和map

set和map的底层数据结构都是红黑树，所以set和map中的元素都是会自动排序的，其查询的时间复杂度是`log n.`

### 问题：hash与unordered_map



# C++11新特性

## 关键字

## 问题：final和override关键字

用于继承关系中的<font color = 'red'>虚函数重写</font>，被final修饰的虚函数，子类中不能够继续重写该虚函数；被override修饰的虚函数表明其父类必须有该虚函数

### 问题：右值引用与左值引用

顾明思义，右值引用是右值的引用，左值引用是左值的引用。具体查看幕布的笔记！！！

接下来就是讲讲什么是左值，什么是右值，举一些例子；

C++左值引用的作用与功能，减少拷贝，可以做函数参数和返回值；

右值引用的作用主要是两个，触发移动语义，实现资源（堆上资源、数据库连接、文件资源）转移.

### 问题：移动拷贝构造函数

**场景**：拷贝构造函数，实际上就是把a对象的内容复制一份到b中，如果b中有指针成员，一般还需要进行新内存的开辟(**深拷贝**)；在程序执行中，可能会有一些**临时对象**或者往后不在使用的对象，**往往只用于传递数据**（没有其它的用处），并且会很快会被销毁。**因此在使用临时对象初始化新对象时，我们可以将其包含的指针成员指向的内存资源直接移给新对象所有(资源的重复利用)**，无需再新拷贝一份，这大大提高了初始化的执行效率。

语法：参数传递使用有值引用；

```C++
#include <iostream>
using namespace std;
 
class A {
public:
	int x;
	A(int x) : x(x)
	{
		cout << "Constructor" << endl;
	}
	A(A& a) : x(a.x)
	{
		cout << "Copy Constructor" << endl;
	}
	A& operator=(A& a)
	{
		x = a.x;
		cout << "Copy Assignment operator" << endl;
		return *this;
	}
	A(A&& a) : x(a.x)
	{
		cout << "Move Constructor" << endl;
	}
	A& operator=(A&& a)
	{
		x = a.x;
		cout << "Move Assignment operator" << endl;
		return *this;
	}
};
 
 
int main()
{
	A a(1);
	A b = a;
	A c(a);
	b = a;
	A e = move(a);  // 配合使用，将左值转化成右值
 
	system("pause");
	return 0;
}
```

### 问题：程序中的零拷贝

对象复用其本质是一种设计模式：Flyweight享元模式。通过将对象存储到“对象池”中实现对象的重复利用，这样可以避免多次创建重复对象的开销，节约系统资源。

零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术，零拷贝技术可以减少数据拷贝和共享总线操作的次数，提高系统效率。

- 在C++中，vector的一个成员函数**emplace_back()**很好地体现了零拷贝技术
- 在I/O读写时，经常会发生程序的零拷贝

# C++的内存布局

##  问题：内存对齐与结构体内部的内存对齐(变量在结构体的偏移)

所谓的内存对齐就是变量的**内存地址必须是某个规定的数字（自然边界）的倍数**。不同的系统采用的编译器的对齐规则可能不同:

```VScode2017```中变量(结构体对象)的对齐规则：

- **基本类型**的自然边界就是其```sizeof```值;
- **结构体(类对象)的对齐规则**：结构体(```struct```)(或联合(`union`))创建的变量(对象)，对齐将按照```#pragma pack```指定的数值和结构(或联合)体的成员中类型长度最大值中，比较**小**的那个进行;[alignas](https://zh.cppreference.com/w/cpp/language/alignas)可以改变其对齐方式
- 结构体内部成员的对齐：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照```#pragma pack``指定的数值和**这个数据成员自身长度**中，比较**小**的那个进行;

可以通过```#pragma pack (n)```改变结构体的对齐规则， n的取值只能是2的指数；

- ```__attribute__((packed))```单字节对齐，紧凑对齐

**为什么要内存对齐**?

1. **平台原因(移植原因)**：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。
2. **性能原因**：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。

### 问题：结构体的变量的偏移量(`offsetof`)

```C++
#include <iostream>
#include <stddef.h>
using namespace std;

struct  S
{
	int x;
	char y;
	int z;
	double a;
};
int main()
{
	cout << offsetof(S, x) << endl; // 0
	cout << offsetof(S, y) << endl; // 4
	cout << offsetof(S, z) << endl; // 8
	cout << offsetof(S, a) << endl; // 12
	return 0;
}
```

### 问题：c/c++两个相同类型的指针变量地址的相减

指针的加减是以sizeof(类型)为单位计数，所以使用时一定铭记这一点。如下就出现了错误情况。

```C++
#include <iostream>
using namespace std;

int main()
{
	int *a, *b, c;
	a = (int*)0x500;
	b = (int*)0x520;
	c = b - a;
	printf("%d\n", c); // 8
	a += 0x020;
	c = b - a;
	printf("%d\n", c); // -24
	return 0;
}
```

## 问题：内存四区

代码区、全局数据区（常量、初始化全局变量、未初始化的全局变量）、堆区、栈区

### 问题：堆区和栈区的区别

- 申请方式(静态，系统维护)和释放方式(动态，程序员维护)
- 申请效率不同：有系统维护的申请效率高(有寄存器记录地址)，不会有内存碎片；堆需要查找合适的内存块，在分配
- 大小不同：栈一般比堆小，可以通过```ulimit```查看堆的大小；
- 内存增长的方向不同：
- **内存管理机制**不同

### 问题：new与 malloc的区别

- 表面上看

  - malloc需要指定大小，new不用(**更简单**)；malloc返回void指针，new直接返回对象类型指针（**安全性**）；malloc不会创建对象，而new会分配空间后在空间上调用构造函数创建对象(**构造函数调用)**，其返回的指针是直接可用的；

  - **内存分配失败处理**：malloc使用NULL判断，new使用异常处理机制处理。

- 从深层次上看：

  - new可以通过malloc分配堆内存实现，且new是操作符，我们有足够的自由去重载operator new /operator delete ,以决定我们的new与delete如何为对象分配内存，如何回收对象。

  - 分配内存的位置不同：malloc从堆中分配，new从自由存储区分配
  - malloc的优势：可以通过remalloc进行扩容，new没有这样直观的配套设施来扩充内存。

### 问题：new和delete底层实现

- new的实现过程是：首先调用名为**operator new**的标准库函数，分配足够大的原始为类型化的内存，以保存指定类型的一个对象；接下来运行该类型的一个构造函数，用指定初始化构造对象；最后返回指向新分配并构造后的的对象的指针;
- delete的实现过程：对指针指向的对象运行适当的析构函数；然后通过调用名为**operator delete**的标准库函数释放该对象所用内存;

### 问题：new[]与 delete[]需不需要配套使用？

对于内置类型：

- new []不会在首地址前4个字节定义数组长度。
- delete 和 delete[]是一样的执行效果，都会删除整个数组，要删除的长度从new时即可知道。

对于自定义类型：

- new []会在**首地址前4个字节**定义数组长度。
- 当delete[]时，会根据前4个字节所定义的长度来执行析构函数删除整个数组。
  如果只是delete数组首地址，只会删除第一个对象的值。
- 特例：如果**不显式地定义析构函数**，则也是可以使用delete删除数组

参考资料：[c++ new delete new[\] delete[] 底层实现_c++ delete 底层做了什么___Lingyue__的博客-CSDN博客](https://blog.csdn.net/cfarmerreally/article/details/54585443)

### 问题：`new`\free与`malloc`\delete混合使用问题

new和malloc在使用上的区别主要在于构造函数有没有被调用；free和delete在使用上的区别主要在于析构函数有没有被调用。

#### 问题：`malloc`/`colloc`/`realloc`

```cpp
void* malloc(unsigned int num_size);
int *p = malloc(20*sizeof(int));申请20个int类型的空间；
    
void* calloc(size_t n,size_t size);
int *p = calloc(20, sizeof(int));

void realloc(void *p, size_t new_size);

```

### 问题：new的三种类型

- 普通new：```new int a;```，调用(内存分配)失败时产生```bad_alloc```异常，通过异常捕捉机制捕获异常；
- 不抛异常new: ```new(nothrow) int b;```，调用(内存分配)失败时和```malloc```一样返回nullptr
- placement new:` new(p) classname c;`，不进行内存空间的申请，能够反复一个已申请的内存空间上，在其上面调用对应类的构造函数，返回指针；使用示例如下：

```c++
#include <iostream>
#include <string>
using namespace std;
class ADT{
	int i;
	int j;
public:
	ADT(){
		i = 10;
		j = 100;
		cout << "ADT construct i=" << i << "j="<<j <<endl;
	}
	~ADT(){
		cout << "ADT destruct" << endl;
	}
};
int main()
{
	char *p = new(nothrow) char[sizeof ADT + 1];
	if (p == NULL) {
		cout << "alloc failed" << endl;
	}
	ADT *q = new(p) ADT;  //placement new:不必担心失败，只要p所指对象的的空间足够ADT创建即可
	//delete q;//错误!不能在此处调用delete q;
	q->ADT::~ADT();//显示调用析构函数
	delete[] p;
	return 0;
}
//输出结果：
//ADT construct i=10j=100
//ADT destruct

```

### 问题：如何通过定义类实现只能静态分配和只能动态分配？(代码实现)

思路：

- 为了实现只能静态分配：那就得将new操作符函数设置为私有，不能被外部调用；
- 为了实现只能动态分配：就需要将构造和析构函数设置为私有，并提供结构函数供外部动态构建对象；

只能静态分配具体实现：

```c++
// 只能在栈上分配内存
class limitB {
public:


private:
	void* operator new(size_t t){}
	void operator delete(void* ptr) {}
};
```

只能动态分配具体实现：

```c++
// 只能在堆上分配内存
class limitA {
public:
	static limitA* creatObj() {  // 提供接口动态创建
		return new limitA();
	}

	void deleteobj() {			 // 提供接口动态析构
		 delete this;
	}

protected:						// 构造函数私有化
	limitA() {

	}

	~limitA() {

	}
};
// 第二种实现方式：通过子类
class limitC : public limitA {

};

int main(){
    limitA* p = limitA::creatObj();
	p->deleteobj();
    
    limitA* a2 = new C;   //  第二种实现方式：通过子类
}
```

### 问题：内存泄漏

内存泄漏问题：动态分配内存后，忘记释放内存，就会产生内存泄漏；

避免方法(常用技巧)：

- 计数法：使用new或者malloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄露；
- 一定要将基类的析构函数声明为**虚函数**；
- 对象数组的释放一定要用**delete []**
- **使用智能指针**

编程时检测内存方法：

- Linux下可以使用**Valgrind工具**
- Windows下可以使用**CRT库**

### 问题：野指针和悬空指针

野指针：指针不知道指向哪，如无初始化的指针；

悬空指针：指针指向一个被释放的内存地址；

# C++代码调试

## 问题：将字符串“hello world”从开始到打印到屏幕上的全过程?

1. 用户告诉操作系统执行HelloWorld程序（通过键盘输入等）

2．操作系统：找到helloworld程序的相关信息，检查其类型是否是可执行文件；并通过程序首部信息，确定代码和数据在可执行文件中的位置并计算出对应的磁盘块地址。

3．操作系统：创建一个新进程，将HelloWorld可执行文件映射到该进程结构，表示由该进程执行helloworld程序。

4．操作系统：为helloworld程序设置cpu上下文环境，并跳到程序开始处。

5．执行helloworld程序的第一条指令，发生缺页异常

6．操作系统：分配一页物理内存，并将代码从磁盘读入内存，然后继续执行helloworld程序

7．helloword程序执行puts函数（系统调用），在显示器上写一字符串

8．操作系统：找到要将字符串送往的显示设备，通常设备是由一个进程控制的，所以，操作系统将要写的字符串送给该进程

9．操作系统：控制设备的进程告诉设备的窗口系统，它要显示该字符串，窗口系统确定这是一个合法的操作，然后将字符串转换成像素，将像素写入设备的存储映像区

10．视频硬件将像素转换成显示器可接收和一组控制数据信号

11．显示器解释信号，激发液晶屏

12．OK，我们在屏幕上看到了HelloWorld

## 问题：C++的main函数执行前还执行了啥函数?

**main函数执行之前**，主要就是初始化系统相关资源：

- 设置栈指针
- 初始化静态`static`变量和`global`全局变量，即`.data`段的内容
- 将未初始化部分的全局变量赋初值：数值型`short`，`int`，`long`等为`0`，`bool`为`FALSE`，指针为`NULL`等等，即`.bss`段的内容
- **全局对象初始化**，在`main`之前调用构造函数，这是可能会执行前的一些代码
- 将main函数的参数`argc`，`argv`等传递给`main`函数，然后才真正运行`main`函数
- `__attribute__((constructor))`

**main函数执行之后**：

- 全局对象的析构函数会在main函数之后执行；
- 可以用 **`atexit`** 注册一个函数，它会在main 之后执行;
- `__attribute__((destructor))`

> 其中`constructor`参数让系统执行`main()`函数之前调用函数(被`__attribute__((constructor))`修饰的函数).同理, `destructor`让系统在`main()`函数退出或者调用了`exit()`之后,调用我们的函数，带有这些修饰属性的函数,对于我们初始化一些在程序中使用的数据非常有用.
> 链接：https://www.jianshu.com/p/dd425b9dc9db

```objectivec
int main(int argc, char * argv[]) {
    @autoreleasepool {
        printf("main function");
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
}
__attribute__((constructor)) static void beforeFunction()
{
    printf("beforeFunction\n");
}

结果：
beforeFunction
main function
```

## 问题：coredupm错误

`coredump`是程序由于异常或者bug在运行时异常退出或者终止，在**一定的条件下**生成的一个叫做core的文件，这个core文件会记录程序在**运行时的内存**，**寄存器状态**，**内存指针**和**函数堆栈信息**等等。

使用gdb命令对core文件进行调试:

```shell
mkdir coredumpTest
vim coredumpTest.cpp

// 写入
#include<stdio.h>
int main(){
    int i;
    scanf("%d",i);//正确的应该是&i,这里使用i会导致segment fault
    printf("%d\n",i);
    return 0;
}

// 编译
g++ coredumpTest.cpp -g -o coredumpTest

// 编译后运行
./coredumpTest

// 使用gbd调试
gdb [可执行文件名] [core文件名]

```

### 问题：函数参数的栈帧

![img](https://pic1.zhimg.com/80/v2-2b66ca077f1b805fe4b578e3c32c80d0_720w.webp)

ebp寄存器和esp寄存器只能保存当前栈空间中最新栈帧的栈底地址和栈顶地址。这也侧面反映了在函数调用，函数之间的栈底和栈顶的值需要进行保存，也就是被调用函数需要把调用函数栈帧的ebp和esp的值保存，腾空出ebp和esp寄存器用于被调用函数的栈帧描述。

## 问题：函数返回值

由此可见，函数调用结束后，**返回值被临时存储到寄存器中**，并没有放到堆或栈中，也就是说与内存没有关系了。当退出函数的时候，临时变量可能被销毁，但是返回值却被放到寄存器中与临时变量的生命周期没有关系。

## 问题：快速定位错误

1、如果是简单的错误，可以直接双击**错误列表**里的错误项或者生成输出的错误信息中带行号的地方就可以让编辑窗口定位到错误的位置上。

2、对于复杂的模板错误，最好使用生成输出窗口。

多数情况下出发错误的位置是最靠后的引用位置。如果这样确定不了错误，就需要先把自己写的代码里的引用位置找出来，然后逐个分析了

## C++的标准库

C++ 标准库可以分为两部分：

- 标准函数库： 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。

- 面向对象类库： 这个库是类及其相关函数的集合。

  1. **输入/输出 I/O**、**字符串和字符处理**、**数学**、**时间*8、日期和本地化、动态分配、其他、宽字符函数；

  2. 标准的 C++ I/O 类、String 类、数值类、STL 容器类、STL 算法、STL 函数对象、STL 迭代器、STL 分配器、本地化库、异常处理类、杂项支持库；
